# 02 GMP 调度

#### Markdown Notes 创建于 2024-08-11T14:07:34.857Z

看这篇。内容比较多。需要有《操作系统》基础（好在学了 408）
[Golang 调度器 GMP 原理与调度全分析](https://learnku.com/articles/41728)

(1) 单进程时代——串行
(2) 多进程 / 线程时代 —— CPU 时间片。 调度消耗资源、内存占用、锁、竞争问题。
(3) 协程。 “内核态”线程和“用户态”线程。细化去分类一下，内核线程依然叫 “线程 (thread)”，用户线程叫 “协程 (co-routine)”

3 种协程和线程的映射关系：

-   N:1 关系
    协程在用户态线程即完成切换，不会陷入到内核态，这种切换非常的轻量快速。
    用不了硬件的多核加速能力。一旦某协程阻塞，造成线程阻塞，本进程的其他协程都无法执行了，根本就没有并发的能力了。
-   1:1 关系
    协程的创建、删除和切换的代价都由 CPU 完成，有点略显昂贵了。
-   M:N 关系
    克服了以上 2 种模型的缺点，但实现起来最为复杂。

线程由 CPU 调度是抢占式的，协程由用户态调度是协作式的。

Go 语言的协程 goroutine
Go 为了提供更容易使用的并发方法，使用了 goroutine 和 channel。
占用内存更小（几 kb）、调度更灵活 (runtime 调度)

## 被废弃的 goroutine 调度器

G--Goroutine 协程。M---machine，现理解为 Thread 线程。
多个 M 访问 G 队列，有互斥锁保护。
激烈的锁竞争、延迟和额外的系统负载、很差的局部性、系统开销

## GMP 模型

引进了 P (Processor) 处理器
线程是运行 goroutine 的实体，调度器的功能是把可运行的 goroutine 分配到工作线程上。
三者工作过程——看图片。
P 和 M 的个数问题。
G 只能运行在 M 中，一个 M 必须持有一个 P
调度器的设计策略：复用线程（可以拿别人的 G；允许 M 换 P）、利用并行、抢占（一个 goroutine 最多占用 CPU 10ms）

go func () 调度流程——看图片。
调度器的生命周期——看图片
特殊的 M0 和 G0

## 可视化 GMP 编程

`go tool trace`
浏览器打开查看可视化的调度流程。

`Debug trace`，先 build 再 debug 运行

## 调度场景过程全解析

看图片、视频

> 自旋本质是在运行，线程在运行却没有执行 G，就变成了浪费 CPU. 为什么不销毁现场，来节约 CPU 资源。因为创建和销毁 CPU 也会浪费时间，我们希望当有新 goroutine 创建时，立刻能有 M 运行它，如果销毁再新建就增加了时延，降低了效率。当然也考虑了过多的自旋线程是浪费 CPU，所以系统中最多有 GOMAXPROCS 个自旋的线程 (当前例子中的 GOMAXPROCS=4，所以一共 4 个 P)，多余的没事做线程会让他们休眠。

**Go 调度本质是把大量的 goroutine 分配到少量线程上去执行，并利用多核并行，实现更强大的并发。**
